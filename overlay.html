<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jarvis 5.0 - True Overlay</title>
    <style>
        /* Reset and base styles */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: transparent;
            color: #fff;
            overflow: hidden;
            -webkit-font-smoothing: antialiased;
            text-rendering: optimizeLegibility;
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 999999;
            pointer-events: none;
        }

        /* Utility classes */
        .hidden {
            display: none !important;
        }

        /* True floating overlay - minimal */
        .overlay {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: transparent;
            z-index: 999999;
            cursor: move;
            animation: slideIn 0.3s ease;
            pointer-events: auto;
            will-change: transform, left, top;
        }

        /* Draggable state */
        .overlay.dragging {
            cursor: grabbing;
            user-select: none;
            transition: none;
        }

        /* Floating Input Area */
        .floating-input {
            display: flex;
            align-items: center;
            gap: 10px;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 30px;
            padding: 8px 15px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            max-width: 500px;
            width: 90%;
            pointer-events: auto;
        }

        #text-input {
            flex: 1;
            background: transparent;
            border: none;
            color: #fff;
            padding: 8px 0;
            font-size: 0.95rem;
            outline: none;
            pointer-events: auto;
        }

        #text-input::placeholder {
            color: rgba(255, 255, 255, 0.5);
        }

        .screenshot-btn, #send-btn {
            background: rgba(255, 255, 255, 0.15);
            border: none;
            color: #fff;
            padding: 8px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 0.9rem;
            width: 36px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s ease;
            pointer-events: auto;
        }

        .screenshot-btn:hover, #send-btn:hover {
            background: rgba(255, 255, 255, 0.25);
        }

        #send-btn {
            background: linear-gradient(45deg, #00d4ff, #00ff88);
            color: #000;
            font-weight: bold;
            border-radius: 20px;
            padding: 8px 15px;
            width: auto;
        }

        #send-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        /* Notification styles */
        .notification {
            display: none !important;
        }

        .notification.show { display: none !important; }

        /* Activation indicator */
        #activation-indicator {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 1000001;
            animation: fadeIn 0.3s ease;
            pointer-events: none;
        }

        .activation-content {
            background: rgba(0, 0, 0, 0.9);
            padding: 2rem 3rem;
            border-radius: 20px;
            text-align: center;
            border: 2px solid #00ff88;
            box-shadow: 0 10px 30px rgba(0, 255, 136, 0.3);
        }

        .jarvis-logo {
            font-size: 4rem;
            margin-bottom: 1rem;
            animation: bounce 0.6s ease;
        }

        .activation-text {
            font-size: 1.5rem;
            font-weight: bold;
            color: #00ff88;
        }

        /* Animations */
        @keyframes slideIn {
            from { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
            to { opacity: 1; transform: translate(-50%, -50%) scale(1); }
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translate(-50%, -50%) translateY(20px); }
            to { opacity: 1; transform: translate(-50%, -50%) translateY(0); }
        }

        @keyframes bounce {
            0%, 20%, 50%, 80%, 100% { transform: translateY(0); }
            40% { transform: translateY(-10px); }
            60% { transform: translateY(-5px); }
        }

        /* Hide overlay initially */
        .overlay.hidden {
            display: none;
        }
    </style>
</head>
<body>
    <!-- True floating overlay - no container -->
    <div id="jarvis-overlay" class="overlay hidden">
        <!-- Just the input area floating -->
        <div class="floating-input">
            <input type="text" id="text-input" placeholder="Ask Jarvis anything...">
            <button class="screenshot-btn" id="capture-screen">ðŸ“·</button>
            <button id="send-btn">Send</button>
        </div>
    </div>

    <!-- Activation indicator -->
    <div id="activation-indicator" class="activation-indicator hidden">
        <div class="activation-content">
            <div class="jarvis-logo">ðŸ¤–</div>
            <div class="activation-text">Jarvis Activated</div>
        </div>
    </div>

    <script>
        class JarvisOverlay {
            constructor() {
                this.overlay = document.getElementById('jarvis-overlay');
                this.textInput = document.getElementById('text-input');
                this.sendBtn = document.getElementById('send-btn');
                this.screenshotBtn = document.getElementById('capture-screen');
                this.activationIndicator = document.getElementById('activation-indicator');
                
                this.isDragging = false;
                this.dragOffset = { x: 0, y: 0 };
                this.conversationHistory = [];
                this.isVisible = false;
                
                this.init();
            }

            init() {
                this.setupEventListeners();
                this.setupDragFunctionality();
                this.setupKeyboardShortcuts();
                
                // Show activation indicator
                this.showActivationIndicator();
                
                // Auto-hide after 2 seconds
                setTimeout(() => {
                    this.hideActivationIndicator();
                }, 2000);
            }

            setupEventListeners() {
                // Send button click
                this.sendBtn.addEventListener('click', () => {
                    this.sendMessage();
                });

                // Enter key in input
                this.textInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        this.sendMessage();
                    }
                });

                // Screenshot button
                this.screenshotBtn.addEventListener('click', () => {
                    this.captureAndAnalyze();
                });

                // Click outside to hide overlay
                document.addEventListener('click', (e) => {
                    if (!this.overlay.contains(e.target) && this.isVisible) {
                        this.hideOverlay();
                    }
                });

                // Double-click anywhere to show overlay
                document.addEventListener('dblclick', (e) => {
                    if (!this.overlay.contains(e.target)) {
                        this.showOverlay();
                    }
                });
            }

            setupDragFunctionality() {
                // Make the entire overlay draggable using CSS positioning
                this.overlay.addEventListener('mousedown', (e) => {
                    // Don't start dragging if clicking on input elements or buttons
                    if (e.target.tagName === 'INPUT' || e.target.tagName === 'BUTTON' || e.target.closest('input') || e.target.closest('button')) {
                        return;
                    }
                    
                    this.isDragging = true;
                    this.overlay.classList.add('dragging');
                    
                    const rect = this.overlay.getBoundingClientRect();
                    this.dragOffset.x = e.clientX - rect.left;
                    this.dragOffset.y = e.clientY - rect.top;
                    
                    e.preventDefault();
                });
                
                document.addEventListener('mousemove', (e) => {
                    if (!this.isDragging) return;
                    
                    const x = e.clientX - this.dragOffset.x;
                    const y = e.clientY - this.dragOffset.y;
                    
                    // Move using CSS positioning - works like a true overlay
                    this.overlay.style.left = x + 'px';
                    this.overlay.style.top = y + 'px';
                    this.overlay.style.transform = 'none';
                    this.overlay.style.position = 'fixed';
                });
                
                document.addEventListener('mouseup', () => {
                    this.isDragging = false;
                    this.overlay.classList.remove('dragging');
                });
            }

            setupKeyboardShortcuts() {
                document.addEventListener('keydown', (e) => {
                    // Command+Shift+Space to toggle overlay
                    if (e.metaKey && e.shiftKey && e.code === 'Space') {
                        e.preventDefault();
                        this.toggleOverlay();
                    }
                    
                    // Escape to hide overlay
                    if (e.key === 'Escape' && this.isVisible) {
                        this.hideOverlay();
                    }
                    
                    // Command+Shift+A to activate
                    if (e.metaKey && e.shiftKey && e.code === 'KeyA') {
                        e.preventDefault();
                        this.showOverlay();
                        this.textInput.focus();
                    }
                });
            }

            showOverlay() {
                this.overlay.classList.remove('hidden');
                this.isVisible = true;
                this.textInput.focus();
            }

            hideOverlay() {
                this.overlay.classList.add('hidden');
                this.isVisible = false;
                this.textInput.blur();
            }

            toggleOverlay() {
                if (this.isVisible) {
                    this.hideOverlay();
                } else {
                    this.showOverlay();
                }
            }

            showActivationIndicator() {
                this.activationIndicator.classList.remove('hidden');
            }

            hideActivationIndicator() {
                this.activationIndicator.classList.add('hidden');
            }

            showNotification(message, duration = 3000) {
                // Create notification element
                const notification = document.createElement('div');
                notification.className = 'notification';
                notification.textContent = message;
                
                document.body.appendChild(notification);
                
                // Show notification
                setTimeout(() => {
                    notification.classList.add('show');
                }, 100);
                
                // Hide notification
                setTimeout(() => {
                    notification.classList.remove('show');
                    setTimeout(() => {
                        if (notification.parentNode) {
                            notification.parentNode.removeChild(notification);
                        }
                    }, 300);
                }, duration);
            }

            async sendMessage() {
                const message = this.textInput.value.trim();
                if (!message) return;

                // Add user message to history
                this.conversationHistory.push({ role: 'user', content: message });
                
                // Clear input and disable send button
                this.textInput.value = '';
                this.sendBtn.disabled = true;
                
                try {
                    // Check if message needs current information
                    if (this.needsCurrentInformation(message)) {
                        const currentInfo = this.getCurrentInformation();
                        const enhancedMessage = `${message}\n\nCurrent information: ${currentInfo}`;
                        
                        const response = await this.callChatGPT(enhancedMessage);
                        this.conversationHistory.push({ role: 'assistant', content: response });
                        this.showNotification(response.substring(0, 100) + '...');
                    } else {
                        // Regular chat
                        const response = await this.callChatGPT(message);
                        this.conversationHistory.push({ role: 'assistant', content: response });
                        this.showNotification(response.substring(0, 100) + '...');
                    }
                    
                    // Limit conversation history to last 10 exchanges (20 messages)
                    if (this.conversationHistory.length > 20) {
                        this.conversationHistory = this.conversationHistory.slice(-20);
                    }
                    
                } catch (error) {
                    console.error('Error sending message:', error);
                    this.showNotification('Error: ' + error.message);
                } finally {
                    this.sendBtn.disabled = false;
                    this.textInput.focus();
                }
            }

            async captureAndAnalyze() {
                this.sendBtn.disabled = true;
                this.screenshotBtn.disabled = true;
                
                try {
                    this.showNotification('Taking screenshot...');
                    
                    // Use HTML5 screen capture API
                    const stream = await navigator.mediaDevices.getDisplayMedia({ 
                        video: { mediaSource: 'screen' } 
                    });
                    
                    const video = document.createElement('video');
                    video.srcObject = stream;
                    video.play();
                    
                    video.onloadedmetadata = () => {
                        const canvas = document.createElement('canvas');
                        canvas.width = video.videoWidth;
                        canvas.height = video.videoHeight;
                        
                        const ctx = canvas.getContext('2d');
                        ctx.drawImage(video, 0, 0);
                        
                        const dataUrl = canvas.toDataURL('image/png');
                        
                        // Stop the stream
                        stream.getTracks().forEach(track => track.stop());
                        
                        // Analyze with OpenAI
                        this.analyzeWithOpenAI(dataUrl, this.textInput.value || 'What am I looking at?');
                    };
                    
                } catch (error) {
                    console.error('Screenshot failed:', error);
                    this.showNotification('Screenshot failed: ' + error.message);
                    this.sendBtn.disabled = false;
                    this.screenshotBtn.disabled = false;
                }
            }

            async analyzeWithOpenAI(imageDataUrl, question) {
                try {
                    this.showNotification('Analyzing screenshot...');
                    
                    const response = await fetch('https://api.openai.com/v1/chat/completions', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': 'Bearer YOUR_OPENAI_API_KEY_HERE' // Replace with your API key
                        },
                        body: JSON.stringify({
                            model: 'gpt-4-vision-preview',
                            messages: [
                                {
                                    role: 'user',
                                    content: [
                                        {
                                            type: 'text',
                                            text: question
                                        },
                                        {
                                            type: 'image_url',
                                            image_url: {
                                                url: imageDataUrl
                                            }
                                        }
                                    ]
                                }
                            ],
                            max_tokens: 300
                        })
                    });

                    if (!response.ok) {
                        throw new Error(`API request failed: ${response.status}`);
                    }

                    const data = await response.json();
                    const analysis = data.choices[0].message.content;
                    
                    // Add to conversation history
                    this.conversationHistory.push({ role: 'assistant', content: analysis });
                    
                    this.showNotification(analysis.substring(0, 100) + '...');
                    
                } catch (error) {
                    console.error('Analysis failed:', error);
                    this.showNotification('Analysis failed: ' + error.message);
                } finally {
                    this.sendBtn.disabled = false;
                    this.screenshotBtn.disabled = false;
                }
            }

            async callChatGPT(message) {
                // Prepare messages with conversation history
                const messages = [
                    { role: 'system', content: 'You are Jarvis, a helpful AI assistant. Be concise and helpful in your responses.' },
                    ...this.conversationHistory.slice(-10), // Last 10 exchanges
                    { role: 'user', content: message }
                ];

                const response = await fetch('https://api.openai.com/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': 'Bearer YOUR_OPENAI_API_KEY_HERE' // Replace with your API key
                    },
                    body: JSON.stringify({
                        model: 'gpt-4',
                        messages: messages,
                        max_tokens: 300
                    })
                });

                if (!response.ok) {
                    throw new Error(`API request failed: ${response.status}`);
                }

                const data = await response.json();
                return data.choices[0].message.content;
            }

            needsCurrentInformation(message) {
                const currentInfoKeywords = ['time', 'date', 'weather', 'news', 'today', 'now', 'current'];
                return currentInfoKeywords.some(keyword => 
                    message.toLowerCase().includes(keyword)
                );
            }

            getCurrentInformation() {
                const now = new Date();
                const timeString = now.toLocaleTimeString();
                const dateString = now.toLocaleDateString();
                
                return `Current time: ${timeString}, Date: ${dateString}`;
            }
        }

        // Initialize Jarvis when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            new JarvisOverlay();
        });

        // Make page fullscreen overlay
        document.addEventListener('DOMContentLoaded', () => {
            // Request fullscreen
            if (document.documentElement.requestFullscreen) {
                document.documentElement.requestFullscreen();
            }
        });
    </script>
</body>
</html>
